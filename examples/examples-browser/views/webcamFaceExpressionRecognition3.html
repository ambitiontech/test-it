<!DOCTYPE html>
<html>
<head>
  <!-- Required meta tags -->
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <script src="face-api.js"></script>
  <script src="js/commons.js"></script>
  <script src="js/faceDetectionControls.js"></script>
  <!--link rel="stylesheet" href="../public/styles-maquette2.css"-->
  <link rel="stylesheet" href="styles-maquette2.css">
  <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/4.0.0/css/bootstrap.min.css" integrity="sha384-Gn5384xqQ1aoWXA+058RXPxPg6fy4IWvTNh0E263XmFcJlSAwiGgFAW/dAiS6JXm" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/materialize/0.100.2/css/materialize.css">
  <script type="text/javascript" src="https://code.jquery.com/jquery-2.1.1.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/materialize/0.100.2/js/materialize.min.js"></script>
</head>
<body>
  <!--div class="container-fluid min-100">
    <div class="flex_container">
      <div class="flex_item_left">
        .....
      </div>
      <div class="flex_item_right">
        .....
      </div>
      <div>
  </div-->

  <div class="container1 min-100">
    <div class="row">
      <div class="flex-container">
        <div class="test-container">
          <img src="../../test.png" height="100%" width="100%"/>
        </div>
        <div class="analyze-container">
          <div class="analyze-container--webcam-wrapper">
            <!--webcam block-->
            <div class="margin">
              <video onloadedmetadata="onPlay(this)" id="inputVideo" autoplay muted playsinline></video>
              <canvas id="overlay" class="video-canvas"/>
            </div>
          </div>
          <div class="analyze-container--sound-wrapper">
            <img data-image-id="1*0CplbBX6gsV-6qV-dBYcnw.gif" data-width="280" data-height="40" data-action="zoom"
                 data-action-value="1*0CplbBX6gsV-6qV-dBYcnw.gif" src="https://hackernoon.com/hn-images/1*0CplbBX6gsV-6qV-dBYcnw.gif" width="288" height="98">
          </div>
          <div class="analyze-container--chatbot-wrapper">
            <img src="https://cdn3.iconfinder.com/data/icons/chat-bot-emoji-blue-filled-color/300/14134081Untitled-3-512.png" width="60px"/>
            <div class="mouvement-logger">

            </div>
          </div>
          <div class="analyze-container--nav-wrapper">
            <div class="container-fluid" style="margin-top: 20px;">
              <div class="row no-margin">
                <div class="col-6 no-margin"><button class="btn btn-primary btn-block">Bouton 1</button></div>
                <div class="col-6 no-margin"><button class="btn btn-primary btn-block">Bouton 2</button></div>
              </div>
              <div class="row">
                <div class="col-12 no-margin"><button class="btn btn-primary btn-block">Bouton 3</button></div>
              </div>
            </div>
          </div>
        </div>
      </div>
    </div>
  </div>


  <!--div id="navbar"></div>
  <div class="center-content page-container">

    <div class="progress" id="loader">
      <div class="indeterminate"></div>
    </div>
    <div style="position: relative" class="margin">
      <video onloadedmetadata="onPlay(this)" id="inputVideo" autoplay muted playsinline></video>
      <canvas id="overlay" />
    </div>

    <div class="row side-by-side"-->

      <!-- face_detector_selection_control -->
      <!--div id="face_detector_selection_control" class="row input-field" style="margin-right: 20px;">
        <select id="selectFaceDetector">
          <option value="ssd_mobilenetv1">SSD Mobilenet V1</option>
          <option value="tiny_face_detector">Tiny Face Detector</option>
          <option value="mtcnn">MTCNN</option>
        </select>
        <label>Select Face Detector22</label>--
      </div>
      <!-- face_detector_selection_control -->

      <!-- check boxes -->
      <!--div class="row" style="width: 220px;">
        <input type="checkbox" id="hideBoundingBoxesCheckbox" onchange="onChangeHideBoundingBoxes(event)" />
        <label for="hideBoundingBoxesCheckbox">Hide Bounding Boxes</label>
      </div-->
      <!-- check boxes -->

      <!-- fps_meter -->
      <!--div id="fps_meter" class="row side-by-side">
        <div>
          <label for="time">Time:</label>
          <input disabled value="-" id="time" type="text" class="bold">
          <label for="fps">Estimated Fps:</label>
          <input disabled value="-" id="fps" type="text" class="bold">
        </div>
      </div-->
      <!-- fps_meter -->

    <!--/div-->

    <!-- ssd_mobilenetv1_controls -->
    <!--span id="ssd_mobilenetv1_controls">
      <div class="row side-by-side">
        <div class="row">
          <label for="minConfidence">Min Confidence:</label>
          <input disabled value="0.5" id="minConfidence" type="text" class="bold">
        </div>
        <button
          class="waves-effect waves-light btn"
          onclick="onDecreaseMinConfidence()"
        >
          <i class="material-icons left">-</i>
        </button>
        <button
          class="waves-effect waves-light btn"
          onclick="onIncreaseMinConfidence()"
        >
          <i class="material-icons left">+</i>
        </button>
      </div>
    </span-->
    <!-- ssd_mobilenetv1_controls -->

    <!-- tiny_face_detector_controls -->
    <!--span id="tiny_face_detector_controls">
      <div class="row side-by-side">
        <div class="row input-field" style="margin-right: 20px;">
          <select id="inputSize">
            <option value="" disabled selected>Input Size:</option>
            <option value="128">128 x 128</option>
            <option value="160">160 x 160</option>
            <option value="224">224 x 224</option>
            <option value="320">320 x 320</option>
            <option value="416">416 x 416</option>
            <option value="512">512 x 512</option>
            <option value="608">608 x 608</option>
          </select>
          <label>Input Size</label>
        </div>
        <div class="row">
          <label for="scoreThreshold">Score Threshold:</label>
          <input disabled value="0.5" id="scoreThreshold" type="text" class="bold">
        </div>
        <button
          class="waves-effect waves-light btn"
          onclick="onDecreaseScoreThreshold()"
        >
          <i class="material-icons left">-</i>
        </button>
        <button
          class="waves-effect waves-light btn"
          onclick="onIncreaseScoreThreshold()"
        >
          <i class="material-icons left">+</i>
        </button>
      </div>
    </span-->
    <!-- tiny_face_detector_controls -->

    <!-- mtcnn_controls -->
    <!--span id="mtcnn_controls">
      <div class="row side-by-side">
        <div class="row">
          <label for="minFaceSize">Minimum Face Size:</label>
          <input disabled value="20" id="minFaceSize" type="text" class="bold">
        </div>
        <button
          class="waves-effect waves-light btn"
          onclick="onDecreaseMinFaceSize()"
        >
          <i class="material-icons left">-</i>
        </button>
        <button
          class="waves-effect waves-light btn"
          onclick="onIncreaseMinFaceSize()"
        >
          <i class="material-icons left">+</i>
        </button>
      </div>
    </span-->
    <!-- mtcnn_controls -->
<!--
  <script src="https://code.jquery.com/jquery-3.2.1.slim.min.js" integrity="sha384-KJ3o2DKtIkvYIK3UENzmM7KCkRr/rE9/Qpg6aAZGJwFDMVNA/GpGFF93hXpG5KkN" crossorigin="anonymous"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/popper.js/1.12.9/umd/popper.min.js" integrity="sha384-ApNbgh9B+Y1QKtv3Rn7W3mgPxhU9K/ScQsAP7hUibX39j7fakFPskvXusvfa0b4Q" crossorigin="anonymous"></script>
  <script src="https://maxcdn.bootstrapcdn.com/bootstrap/4.0.0/js/bootstrap.min.js" integrity="sha384-JZR6Spejh4U02d8jOt6vLEHfe/JQGiRRSQQxSfFWpi1MquVdAyjUar5+76PVCmYl" crossorigin="anonymous"></script>


  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/materialize/0.100.2/css/materialize.css">
  <script src="https://cdnjs.cloudflare.com/ajax/libs/materialize/0.100.2/js/materialize.min.js"></script>

  -->
</body>


  <script>

    let forwardTimes = []
    let withBoxes = false

    function onChangeHideBoundingBoxes(e) {
      withBoxes = !$(e.target).prop('checked')
    }

    function updateTimeStats(timeInMs) {
      forwardTimes = [timeInMs].concat(forwardTimes).slice(0, 30)
      const avgTimeInMs = forwardTimes.reduce((total, t) => total + t) / forwardTimes.length
      $('#time').val(`${Math.round(avgTimeInMs)} ms`)
      $('#fps').val(`${faceapi.round(1000 / avgTimeInMs)}`)
    }

    function calculateRefLength(pointA, pointB){
      let a = Math.abs(pointA.x - pointB.x)
      let b = Math.abs(pointA.y - pointB.y)
      return (Math.sqrt((Math.pow(a, 2)) + (Math.pow(b, 2))))
    }

    function verticalPointsValide(point27, point33, point8){
      this.point27 = point27;
      this.point33 = point33;
      this.point8 = point8;
    }

    /**
     *
     * Exemple de Singleton en JS
     **/


    var Singleton = (function () {
      var instance;

      function createInstance() {
        var object = new Object("I am the instance");
        return object;
      }

      return {
        getInstance: function () {
          if (!instance) {
            instance = createInstance();
          }
          return instance;
        }
      };
    })();

    function run() {

      var instance1 = Singleton.getInstance();
      var instance2 = Singleton.getInstance();

      alert("Same instance? " + (instance1 === instance2));
    }

    function chatBotLog(expressions) {
      const chatBot = $('.mouvement-logger').get(0);

      let result = '';

      let expressionArray = Object.keys(expressions);

      expressionArray.map(function(element) {
        if(expressions[element] > 0.5){
          result += element + ": " + expressions[element] + "<br/>";
        }
      });

      chatBot.innerHTML = result;

      /*
      const object1 = {
        a: 'somestring',
        b: 42,
        c: false
      };

      console.log(Object.keys(object1));
// expected output: Array ["a", "b", "c"]
      */



      /**
      var nombres = [1, 4, 9];
      var doubles = nombres.map(function(num) {
        return num * 2;
      });
      */

      /**
      expressions.map(function(element) {
        console.log(element);
      });
       */
    }

    function addDirectionsExpressions(refPoints, origExpressions) {
      const LEFT_FACE_POINT_NUMBER = 1
      const RIGHT_FACE_POINT_NUMBER = 15
      const NOSE_POINT_NUMBER = 33
      const TOP_NOSE_POINT_NUMBER = 27
      const CHIN_POINT_NUMBER = 8

      /** horizontal params **/
      const HORIZONTAL_ROTATION_AVR = 0.9
      const DIRECTION_DISPLAY_MIN_PROB = 0.5

      /** vertical params **/

      //init all expressions
      origExpressions.angry = 0.0;
      origExpressions.disgusted = 0.0;
      origExpressions.fearful = 0.0;
      origExpressions.happy = 0.0;
      origExpressions.neutral = 0.0;
      origExpressions.sad = 0.0;
      origExpressions.surprised = 0.0;

      origExpressions.left = 0.0;
      origExpressions.right = 0.0;
      origExpressions.up = 0.0;
      origExpressions.down = 0.0;

      let _left = calculateRefLength(refPoints[LEFT_FACE_POINT_NUMBER], refPoints[NOSE_POINT_NUMBER]);
      let _right = calculateRefLength(refPoints[RIGHT_FACE_POINT_NUMBER], refPoints[NOSE_POINT_NUMBER]);
      let _up = calculateRefLength(refPoints[CHIN_POINT_NUMBER], refPoints[NOSE_POINT_NUMBER]);
      let _down = calculateRefLength(refPoints[TOP_NOSE_POINT_NUMBER], refPoints[NOSE_POINT_NUMBER]);

      /** algo left-right **/
      if((_left > _right) && ((_right / _left) < HORIZONTAL_ROTATION_AVR)){
        origExpressions.left = -((DIRECTION_DISPLAY_MIN_PROB/HORIZONTAL_ROTATION_AVR)*(_right/_left)) + 1;
      }

      if((_right > _left) && ((_left / _right) < HORIZONTAL_ROTATION_AVR)){
        origExpressions.right = -((DIRECTION_DISPLAY_MIN_PROB/HORIZONTAL_ROTATION_AVR)*(_left/_right)) + 1;
      }

      /** algo up down **/
      let vertcalRate = (_up > _down) ?  (_down/_up) : (_up/_down);
      let valideVerticalRate = (vertcalRate > 0.45 && vertcalRate < 0.45);

      if(valideVerticalRate) {

      }


      return origExpressions;
    }

    async function onPlay() {
      const videoEl = $('#inputVideo').get(0)

      if(videoEl.paused || videoEl.ended || !isFaceDetectionModelLoaded())
        return setTimeout(() => onPlay())


      const options = getFaceDetectorOptions()

      const ts = Date.now()

      const result = await faceapi.detectSingleFace(videoEl, options).withFaceLandmarks().withFaceExpressions()

      //console.log('test detection')

      updateTimeStats(Date.now() - ts)

      //$result = false;

      if (result) {
        const canvas = $('#overlay').get(0)
        const dims = faceapi.matchDimensions(canvas, videoEl, true)

        const resizedResult = faceapi.resizeResults(result, dims)

        // todo : récuperer les coordonnéesdes 5 points calculer les distance et prédire la direction du visage.
        // Problématique de la prédiction verticale -> angle caméra -> topographie du visage -> init coordonnées de départ.
        // Surcharge du rapport -> quantification : gauche, droite, haute, bas, en probabilités.
        /**
         *            27
         *
         *      1     33      RIGHT_FACE_POINT_NUMBER
         *
         *            8
         */


        let faceRefPoint = {
          pointNumber : null,
          x : null,
          y : null,
        }

        /**
        faceRefPoint.pointNumber = 5
        faceRefPoint.x = 2
        faceRefPoint.y = 2

        faceRefPoint.u = 4

        console.log(' surcharge obj ', faceRefPoint)
        */

        let faceRefPoints = []


        //console.log(Array.from(resizedResult.unshiftedLandmarks.positions))


        resizedResult.unshiftedLandmarks.positions.forEach(function(element, idx) {
          //console.log('ele : ' + element._x);
          var _faceRefPoint = {
            pointNumber : idx,
            x : element._x,
            y : element._y,
          }

          //if(faceRefPointsIndexs.indexOf(idx) !== -1)
            faceRefPoints.push(_faceRefPoint)
        })

        //console.log('dd -> ' + faceRefPoints[33])

        //************************************************************console.log(faceRefPoints);

        /**
        faceRefPoints['1'] = resizedResult.unshiftedLandmarks.positions.indexOf(1)
        faceRefPoints['8'] = resizedResult.unshiftedLandmarks.positions.indexOf(8)
        faceRefPoints['RIGHT_FACE_POINT_NUMBER'] = resizedResult.unshiftedLandmarks.positions.indexOf(RIGHT_FACE_POINT_NUMBER)
        faceRefPoints['27'] = resizedResult.unshiftedLandmarks.positions.indexOf(27)
        faceRefPoints['33'] = resizedResult.unshiftedLandmarks.positions.indexOf(33)
        */



        //consol.log('rr' + resizedResult.unshiftedLandmarks.positions.indexOf(33))

        /**
        console.log('positions' + resizedResult.unshiftedLandmarks);
        console.log('faceRefPointsIndexs.length' + faceRefPointsIndexs.length);


        let i = 0;
        faceRefPointsIndexs.forEach(function(element) {
          i ++
          //console.log(element);
          //index =>
          //faceRefPoints[element] = resizedResult.unshiftedLandmarks.positions[element]
        })

        console.log('i : '+i);
         */

        //resizedResult.unshiftedLandmarks.positions[1]

        //console.log('faceRefPoints.length' + faceRefPoints.length);
        //console.log('beforre',resizedResult.expressions);


        resizedResult.expressions = addDirectionsExpressions(faceRefPoints, resizedResult.expressions)

        //console.log(resizedResult.expressions);
        chatBotLog(resizedResult.expressions);

        const minConfidence = 0.05
        if (withBoxes) {
          faceapi.draw.drawDetections(canvas, resizedResult)
        }
        //faceapi.draw.drawFaceExpressions(canvas, resizedResult, minConfidence)   avec proba
      }



      setTimeout(() => onPlay())
    }

    async function run() {
      // load face detection and face expression recognition models
      await changeFaceDetector(TINY_FACE_DETECTOR)
      await faceapi.loadFaceLandmarkModel('/')
      await faceapi.loadFaceExpressionModel('/')
      changeInputSize(224)

      // try to access users webcam and stream the images
      // to the video element


      /**
      const stream = await navigator.mediaDevices.getUserMedia({ video: {} })
      audio: true,
        video: {
        width: { min: 1280 },
        height: { min: 720 }
      }
       */
      var constraints = {
        audio: true,
        video: {
          width: { min: 260, ideal: 288, max: 288 },
          height: { min: 190, ideal: 220, max: 230 }
        }
      }

      const stream = await navigator.mediaDevices.getUserMedia(constraints)
      const videoEl = $('#inputVideo').get(0)
      videoEl.srcObject = stream
    }

    function updateResults() {}

    /**
    function resizeVideo() {
      const canvas = $('#overlay').get(0)
      //document.getElementById("myBtn").style.width = "300px";
      canvas.style.width = "280px";
    }
     */

    $(document).ready(function() {
      //renderNavBar('#navbar', 'webcam_face_expression_recognition3')
      initFaceDetectionControls()
      run()
      //resizeVideo()
    })
  </script>
</body>
</html>
